# 065. 3Sum

**Difficulty:** MEDIUM
**Frequency:** 47.0%
**Acceptance Rate:** 37.1%
**LeetCode Link:** [3Sum](https://leetcode.com/problems/3sum)

---

## Problem Description

Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

**Constraints:**
- 3 <= nums.length <= 3000
- -10^5 <= nums[i] <= 10^5

---

## Examples

### Example 1
**Input:** `nums = [-1,0,1,2,-1,-4]`
**Output:** `[[-1,-1,2],[-1,0,1]]`
**Explanation:** Two unique triplets sum to 0

### Example 2
**Input:** `nums = [0,1,1]`
**Output:** `[]`
**Explanation:** No triplet sums to 0

### Example 3
**Input:** `nums = [0,0,0]`
**Output:** `[[0,0,0]]`
**Explanation:** Three zeros sum to 0

### Example 4
**Input:** `nums = [-2,0,1,1,2]`
**Output:** `[[-2,0,2],[-2,1,1]]`
**Explanation:** Multiple valid triplets

---

## Optimal Solution

### Implementation

```python
def threeSum(nums: List[int]) -> List[List[int]]:
    """
    Sort + two pointers for O(n²) solution.

    Time: O(n²), Space: O(1) excluding output
    """
    nums.sort()
    result = []

    for i in range(len(nums) - 2):
        # Skip duplicates for first number
        if i > 0 and nums[i] == nums[i-1]:
            continue

        left, right = i + 1, len(nums) - 1
        target = -nums[i]

        while left < right:
            current_sum = nums[left] + nums[right]

            if current_sum == target:
                result.append([nums[i], nums[left], nums[right]])

                # Skip duplicates
                while left < right and nums[left] == nums[left+1]:
                    left += 1
                while left < right and nums[right] == nums[right-1]:
                    right -= 1

                left += 1
                right -= 1
            elif current_sum < target:
                left += 1
            else:
                right -= 1

    return result
```

### Complexity Analysis

**Time: O(n²) - nested iteration. Space: O(1) - excluding output**

**Why This is Optimal:**
- Achieves best possible asymptotic complexity for this problem class
- Minimal space overhead while maintaining code clarity
- Scales efficiently with large inputs
- Handles all edge cases correctly

---

## Categories & Tags

**Primary Topics:** Array, Two Pointers, Sorting

**Difficulty Level:** MEDIUM

---

---

*Problem source: [LeetCode](https://leetcode.com/problems/3sum)*
